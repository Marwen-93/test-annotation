import { EventEmitter, Component, Input, Output, ElementRef, NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function AnnotationComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵelementStart(2, "button", 5);
    ɵngcc0.ɵɵlistener("click", function AnnotationComponent_span_5_Template_button_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.removeAnnotation.emit(ctx_r1.annotation); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NgxAnnotateTextComponent_span_0_ngx_annotation_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-annotation", 3);
    ɵngcc0.ɵɵlistener("removeAnnotation", function NgxAnnotateTextComponent_span_0_ngx_annotation_1_Template_ngx_annotation_removeAnnotation_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(2); return ctx_r4.onRemoveAnnotation($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const token_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r2.annotationClass || "");
    ɵngcc0.ɵɵproperty("annotation", token_r1)("removable", ctx_r2.removable);
} }
function NgxAnnotateTextComponent_span_0_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const token_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(token_r1);
} }
function NgxAnnotateTextComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, NgxAnnotateTextComponent_span_0_ngx_annotation_1_Template, 1, 4, "ngx-annotation", 1);
    ɵngcc0.ɵɵtemplate(2, NgxAnnotateTextComponent_span_0_span_2_Template, 2, 1, "span", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const token_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isAnnotation(token_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.isAnnotation(token_r1));
} }
class AnnotationComponent {
    constructor() {
        this.removable = true;
        this.removeAnnotation = new EventEmitter();
    }
}
AnnotationComponent.ɵfac = function AnnotationComponent_Factory(t) { return new (t || AnnotationComponent)(); };
AnnotationComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AnnotationComponent, selectors: [["ngx-annotation"]], inputs: { removable: "removable", annotation: "annotation" }, outputs: { removeAnnotation: "removeAnnotation" }, decls: 6, vars: 9, consts: [[1, "annotation-parent"], [1, "annotation-content"], [1, "annotation-label"], ["class", "annotation-button", 4, "ngIf"], [1, "annotation-button"], [1, "remove-annotation", 3, "click"]], template: function AnnotationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵelementStart(2, "pre");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "span", 2);
        ɵngcc0.ɵɵtemplate(5, AnnotationComponent_span_5_Template, 3, 0, "span", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("border-color", ctx.annotation.color)("background-color", ctx.annotation.color);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.annotation.text);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background-color", ctx.annotation.color);
        ɵngcc0.ɵɵattribute("data-label", ctx.annotation.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.removable);
    } }, directives: [ɵngcc1.NgIf], styles: ["span.annotation-parent[_ngcontent-%COMP%]{border:2px solid;border-radius:4px;box-shadow:2px 4px 20px rgba(0,0,0,.1);color:rgba(0,0,0,.6);display:block;font-weight:500;line-height:1.5;margin:0 0 .5rem;min-width:26px;padding:0;white-space:normal;word-break:break-word;word-wrap:break-word}span.annotation-content[_ngcontent-%COMP%]{align-items:center;background-color:#fff;border-top-left-radius:2px;border-top-right-radius:2px;display:flex;flex-wrap:wrap;justify-content:center;padding:0 2px;text-align:center;white-space:normal}span.annotation-content[_ngcontent-%COMP%]   pre[_ngcontent-%COMP%]{background-color:transparent;box-sizing:border-box;color:inherit;display:block;font-family:inherit;font-size:inherit;margin-bottom:0;margin-top:0;overflow:auto;padding:0}span.annotation-label[_ngcontent-%COMP%]{-webkit-touch-callout:none;-webkit-user-select:none;align-items:center;color:#fff;display:flex;justify-content:center;line-height:.8rem;margin:0;padding:2px 8px 0;text-align:center;user-select:none}span.annotation-label[_ngcontent-%COMP%]:after{content:attr(data-label)}span.annotation-button[_ngcontent-%COMP%]{display:block;height:0;position:relative;width:100%}span.annotation-button[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:absolute;right:.47rem;top:-2.9rem}button.remove-annotation[_ngcontent-%COMP%]{-moz-appearance:none;-webkit-appearance:none;-webkit-user-select:none;appearance:none;background-color:rgba(10,10,10,.2);border:none;border-radius:1000px;cursor:pointer;display:inline-block;flex-grow:0;flex-shrink:0;height:16px;max-height:16px;max-width:16px;min-height:16px;min-width:16px;outline:0;position:absolute;user-select:none;width:16px}button.remove-annotation[_ngcontent-%COMP%]:hover{background-color:rgba(10,10,10,.5)}button.remove-annotation[_ngcontent-%COMP%]:after, button.remove-annotation[_ngcontent-%COMP%]:before{background-color:#fff;content:\"\";display:block;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%) rotate(45deg);transform-origin:center center}button.remove-annotation[_ngcontent-%COMP%]:after{height:50%;width:2px}button.remove-annotation[_ngcontent-%COMP%]:before{height:2px;width:50%}"] });
AnnotationComponent.ctorParameters = () => [];
AnnotationComponent.propDecorators = {
    annotation: [{ type: Input }],
    removable: [{ type: Input }],
    removeAnnotation: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AnnotationComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-annotation',
                template: "<span class=\"annotation-parent\" [style.border-color]=\"annotation.color\" [style.background-color]=\"annotation.color\">\n\n    <span class=\"annotation-content\">\n        <pre>{{ annotation.text }}</pre>\n    </span>\n\n    <!-- Instead of setting the property \"innerText\" of this HTML element, we set \"data-label\".\n        In CSS, we can then reference the content of this property and can use the CSS pseudo-\n        element \"::after\" to insert the content of \"data-label\" as text into the DOM.\n        What's the advantage of this? At first, I tried to use the \"innerText\" property of this\n        HTML element to visualize the annotation's label. Whenever the user selected a range of\n        the original text, then the labels of the annotations were counted into the range, too.\n        This made it difficult to extract which text range the user actually selected. By using\n        the CSS pseudo-class \"::after\", we can prevent the annotations' labels from being\n        included into the selected text range. -->\n    <span class=\"annotation-label\" [attr.data-label]=\"annotation.label\" [style.background-color]=\"annotation.color\">\n    </span>\n\n    <span class=\"annotation-button\" *ngIf=\"removable\">\n        <span>\n            <button class=\"remove-annotation\" (click)=\"removeAnnotation.emit(annotation)\">\n            </button>\n        </span>\n    </span>\n\n</span>",
                styles: ["span.annotation-parent{border:2px solid;border-radius:4px;box-shadow:2px 4px 20px rgba(0,0,0,.1);color:rgba(0,0,0,.6);display:block;font-weight:500;line-height:1.5;margin:0 0 .5rem;min-width:26px;padding:0;white-space:normal;word-break:break-word;word-wrap:break-word}span.annotation-content{align-items:center;background-color:#fff;border-top-left-radius:2px;border-top-right-radius:2px;display:flex;flex-wrap:wrap;justify-content:center;padding:0 2px;text-align:center;white-space:normal}span.annotation-content pre{background-color:transparent;box-sizing:border-box;color:inherit;display:block;font-family:inherit;font-size:inherit;margin-bottom:0;margin-top:0;overflow:auto;padding:0}span.annotation-label{-webkit-touch-callout:none;-webkit-user-select:none;align-items:center;color:#fff;display:flex;justify-content:center;line-height:.8rem;margin:0;padding:2px 8px 0;text-align:center;user-select:none}span.annotation-label:after{content:attr(data-label)}span.annotation-button{display:block;height:0;position:relative;width:100%}span.annotation-button span{position:absolute;right:.47rem;top:-2.9rem}button.remove-annotation{-moz-appearance:none;-webkit-appearance:none;-webkit-user-select:none;appearance:none;background-color:rgba(10,10,10,.2);border:none;border-radius:1000px;cursor:pointer;display:inline-block;flex-grow:0;flex-shrink:0;height:16px;max-height:16px;max-width:16px;min-height:16px;min-width:16px;outline:0;position:absolute;user-select:none;width:16px}button.remove-annotation:hover{background-color:rgba(10,10,10,.5)}button.remove-annotation:after,button.remove-annotation:before{background-color:#fff;content:\"\";display:block;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%) rotate(45deg);transform-origin:center center}button.remove-annotation:after{height:50%;width:2px}button.remove-annotation:before{height:2px;width:50%}"]
            }]
    }], function () { return []; }, { removable: [{
            type: Input
        }], removeAnnotation: [{
            type: Output
        }], annotation: [{
            type: Input
        }] }); })();

class Annotation {
    /**
     * Represents an annotated part of the referenced text.
     *
     * @param startIndex The zero-based index number indicating the beginning of this annotation.
     * @param endIndex The zero-based index number indicating the end of the annotation. The annotation
     * includes the characters up to, but not including, the character indicated by the end.
     * @param label Arbitrary string displayed as label below the annotation, e. g. `City`.
     * @param color The color of the box which is displayed around the annotation, e. g. 'red' or 'rgb(220, 53, 69)'.
     */
    constructor(startIndex, endIndex, label, color) {
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.label = label;
        this.color = color;
    }
}

class NgxAnnotateTextComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /** Represents the parts of the given text which shall be annotated. */
        this.annotations = [];
        /**
         * Determines whether annotations shall have a small button in the top right corner so that the user can
         * remove an annotation.
         */
        this.removable = true;
        /** Emits the list of existing annotations after an element has been removed. */
        this.annotationsChange = new EventEmitter();
        /** @internal */
        this.tokens = [];
        this.annotationStartingIndices = new Map();
    }
    ngOnInit() {
        this.splitTextIntoTokens();
    }
    ngOnChanges(changes) {
        if ('annotations' in changes || 'text' in changes) {
            this.splitTextIntoTokens();
        }
    }
    /**
     * Returns the start index and end index of the currently selected text range. Returns `undefined`
     * if no text is currently selected.
     */
    getCurrentTextSelection() {
        this.updateTextSelection();
        if (this.selectionStart === undefined || this.selectionEnd === undefined || this.selectionStart >= this.selectionEnd) {
            return undefined;
        }
        return {
            startIndex: this.selectionStart,
            endIndex: this.selectionEnd,
        };
    }
    /** @internal */
    isAnnotation(annotation) {
        return annotation instanceof Annotation;
    }
    /** @internal */
    onRemoveAnnotation(annotation) {
        this.annotations = this.annotations.filter(a => a !== annotation);
        this.annotationsChange.emit(this.annotations);
        this.splitTextIntoTokens();
    }
    updateTextSelection() {
        if (window.getSelection && window.getSelection().rangeCount > 0) {
            const range = window.getSelection().getRangeAt(0);
            const preSelectionRange = range.cloneRange();
            preSelectionRange.selectNodeContents(this.elementRef.nativeElement);
            preSelectionRange.setEnd(range.startContainer, range.startOffset);
            this.selectionStart = [...preSelectionRange.toString()].length;
            this.selectionEnd = this.selectionStart + [...range.toString()].length;
        }
        else {
            this.selectionStart = undefined;
            this.selectionEnd = undefined;
        }
    }
    splitTextIntoTokens() {
        this.tokens = [];
        this.annotationStartingIndices = new Map();
        // Creates a map which contains the starting indices for each annotation
        // as keys. This way, we know the positions / indices in the text where
        // we need to display an annotation instead of the plaintext.
        this.annotations.forEach((a) => {
            this.annotationStartingIndices.set(a.startIndex, a);
            a.text = this.text.substring(a.startIndex, a.endIndex);
        });
        let currentIndex = 0;
        let isAnnotationActive = false;
        let annotationActiveUntilIndex = 0;
        let buffer = '';
        this.text.split('').forEach((char) => {
            if (annotationActiveUntilIndex === currentIndex) {
                isAnnotationActive = false;
            }
            if (!this.annotationStartingIndices.has(currentIndex) && !isAnnotationActive) {
                buffer += char;
            }
            else if (this.annotationStartingIndices.has(currentIndex)) {
                if (buffer.length > 0) {
                    this.tokens.push(buffer);
                }
                this.tokens.push(this.annotationStartingIndices.get(currentIndex));
                annotationActiveUntilIndex = this.annotationStartingIndices.get(currentIndex).endIndex;
                buffer = '';
                isAnnotationActive = true;
            }
            currentIndex++;
        });
        if (buffer.length > 0) {
            this.tokens.push(buffer);
        }
    }
}
NgxAnnotateTextComponent.ɵfac = function NgxAnnotateTextComponent_Factory(t) { return new (t || NgxAnnotateTextComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxAnnotateTextComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxAnnotateTextComponent, selectors: [["ngx-annotate-text"]], inputs: { annotations: "annotations", removable: "removable", annotationClass: "annotationClass", text: "text" }, outputs: { annotationsChange: "annotationsChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], [3, "annotation", "removable", "class", "removeAnnotation", 4, "ngIf"], ["class", "unlabeled", 4, "ngIf"], [3, "annotation", "removable", "removeAnnotation"], [1, "unlabeled"]], template: function NgxAnnotateTextComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxAnnotateTextComponent_span_0_Template, 3, 2, "span", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tokens);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, AnnotationComponent], styles: ["[_nghost-%COMP%]{align-items:flex-start;display:flex;flex-wrap:wrap;white-space:pre-wrap}span.unlabeled[_ngcontent-%COMP%]{line-height:1.5rem}"] });
NgxAnnotateTextComponent.ctorParameters = () => [
    { type: ElementRef }
];
NgxAnnotateTextComponent.propDecorators = {
    annotations: [{ type: Input }],
    annotationClass: [{ type: Input }],
    removable: [{ type: Input }],
    text: [{ type: Input }],
    annotationsChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxAnnotateTextComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-annotate-text',
                template: "<span *ngFor=\"let token of tokens\">\n\n  <ngx-annotation *ngIf=\"isAnnotation(token)\" [annotation]=\"token\" [removable]=\"removable\"\n    (removeAnnotation)=\"onRemoveAnnotation($event)\" [class]=\"(annotationClass || '')\">\n  </ngx-annotation>\n\n  <span *ngIf=\"!isAnnotation(token)\" class=\"unlabeled\">{{ token }}</span>\n\n</span>",
                styles: [":host(){align-items:flex-start;display:flex;flex-wrap:wrap;white-space:pre-wrap}span.unlabeled{line-height:1.5rem}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { annotations: [{
            type: Input
        }], removable: [{
            type: Input
        }], annotationsChange: [{
            type: Output
        }], annotationClass: [{
            type: Input
        }], text: [{
            type: Input
        }] }); })();

class NgxAnnotateTextModule {
}
NgxAnnotateTextModule.ɵfac = function NgxAnnotateTextModule_Factory(t) { return new (t || NgxAnnotateTextModule)(); };
NgxAnnotateTextModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxAnnotateTextModule });
NgxAnnotateTextModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            BrowserModule,
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxAnnotateTextModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    AnnotationComponent,
                    NgxAnnotateTextComponent,
                ],
                imports: [
                    BrowserModule,
                ],
                exports: [NgxAnnotateTextComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxAnnotateTextModule, { declarations: function () { return [AnnotationComponent, NgxAnnotateTextComponent]; }, imports: function () { return [BrowserModule]; }, exports: function () { return [NgxAnnotateTextComponent]; } }); })();

/*
 * Public API Surface of ngx-annotate-text
 */

/**
 * Generated bundle index. Do not edit.
 */

export { Annotation, NgxAnnotateTextComponent, NgxAnnotateTextModule, AnnotationComponent as ɵa };

//# sourceMappingURL=ngx-annotate-text.js.map