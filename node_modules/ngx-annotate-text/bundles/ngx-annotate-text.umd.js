(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('ngx-annotate-text', ['exports', '@angular/core', '@angular/platform-browser'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-annotate-text'] = {}, global.ng.core, global.ng.platformBrowser));
}(this, (function (exports, core, platformBrowser) { 'use strict';

    var AnnotationComponent = /** @class */ (function () {
        function AnnotationComponent() {
            this.removable = true;
            this.removeAnnotation = new core.EventEmitter();
        }
        return AnnotationComponent;
    }());
    AnnotationComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-annotation',
                    template: "<span class=\"annotation-parent\" [style.border-color]=\"annotation.color\" [style.background-color]=\"annotation.color\">\n\n    <span class=\"annotation-content\">\n        <pre>{{ annotation.text }}</pre>\n    </span>\n\n    <!-- Instead of setting the property \"innerText\" of this HTML element, we set \"data-label\".\n        In CSS, we can then reference the content of this property and can use the CSS pseudo-\n        element \"::after\" to insert the content of \"data-label\" as text into the DOM.\n        What's the advantage of this? At first, I tried to use the \"innerText\" property of this\n        HTML element to visualize the annotation's label. Whenever the user selected a range of\n        the original text, then the labels of the annotations were counted into the range, too.\n        This made it difficult to extract which text range the user actually selected. By using\n        the CSS pseudo-class \"::after\", we can prevent the annotations' labels from being\n        included into the selected text range. -->\n    <span class=\"annotation-label\" [attr.data-label]=\"annotation.label\" [style.background-color]=\"annotation.color\">\n    </span>\n\n    <span class=\"annotation-button\" *ngIf=\"removable\">\n        <span>\n            <button class=\"remove-annotation\" (click)=\"removeAnnotation.emit(annotation)\">\n            </button>\n        </span>\n    </span>\n\n</span>",
                    styles: ["span.annotation-parent{border:2px solid;border-radius:4px;box-shadow:2px 4px 20px rgba(0,0,0,.1);color:rgba(0,0,0,.6);display:block;font-weight:500;line-height:1.5;margin:0 0 .5rem;min-width:26px;padding:0;white-space:normal;word-break:break-word;word-wrap:break-word}span.annotation-content{align-items:center;background-color:#fff;border-top-left-radius:2px;border-top-right-radius:2px;display:flex;flex-wrap:wrap;justify-content:center;padding:0 2px;text-align:center;white-space:normal}span.annotation-content pre{background-color:transparent;box-sizing:border-box;color:inherit;display:block;font-family:inherit;font-size:inherit;margin-bottom:0;margin-top:0;overflow:auto;padding:0}span.annotation-label{-webkit-touch-callout:none;-webkit-user-select:none;align-items:center;color:#fff;display:flex;justify-content:center;line-height:.8rem;margin:0;padding:2px 8px 0;text-align:center;user-select:none}span.annotation-label:after{content:attr(data-label)}span.annotation-button{display:block;height:0;position:relative;width:100%}span.annotation-button span{position:absolute;right:.47rem;top:-2.9rem}button.remove-annotation{-moz-appearance:none;-webkit-appearance:none;-webkit-user-select:none;appearance:none;background-color:rgba(10,10,10,.2);border:none;border-radius:1000px;cursor:pointer;display:inline-block;flex-grow:0;flex-shrink:0;height:16px;max-height:16px;max-width:16px;min-height:16px;min-width:16px;outline:0;position:absolute;user-select:none;width:16px}button.remove-annotation:hover{background-color:rgba(10,10,10,.5)}button.remove-annotation:after,button.remove-annotation:before{background-color:#fff;content:\"\";display:block;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%) rotate(45deg);transform-origin:center center}button.remove-annotation:after{height:50%;width:2px}button.remove-annotation:before{height:2px;width:50%}"]
                },] }
    ];
    AnnotationComponent.ctorParameters = function () { return []; };
    AnnotationComponent.propDecorators = {
        annotation: [{ type: core.Input }],
        removable: [{ type: core.Input }],
        removeAnnotation: [{ type: core.Output }]
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var Annotation = /** @class */ (function () {
        /**
         * Represents an annotated part of the referenced text.
         *
         * @param startIndex The zero-based index number indicating the beginning of this annotation.
         * @param endIndex The zero-based index number indicating the end of the annotation. The annotation
         * includes the characters up to, but not including, the character indicated by the end.
         * @param label Arbitrary string displayed as label below the annotation, e. g. `City`.
         * @param color The color of the box which is displayed around the annotation, e. g. 'red' or 'rgb(220, 53, 69)'.
         */
        function Annotation(startIndex, endIndex, label, color) {
            this.startIndex = startIndex;
            this.endIndex = endIndex;
            this.label = label;
            this.color = color;
        }
        return Annotation;
    }());

    var NgxAnnotateTextComponent = /** @class */ (function () {
        function NgxAnnotateTextComponent(elementRef) {
            this.elementRef = elementRef;
            /** Represents the parts of the given text which shall be annotated. */
            this.annotations = [];
            /**
             * Determines whether annotations shall have a small button in the top right corner so that the user can
             * remove an annotation.
             */
            this.removable = true;
            /** Emits the list of existing annotations after an element has been removed. */
            this.annotationsChange = new core.EventEmitter();
            /** @internal */
            this.tokens = [];
            this.annotationStartingIndices = new Map();
        }
        NgxAnnotateTextComponent.prototype.ngOnInit = function () {
            this.splitTextIntoTokens();
        };
        NgxAnnotateTextComponent.prototype.ngOnChanges = function (changes) {
            if ('annotations' in changes || 'text' in changes) {
                this.splitTextIntoTokens();
            }
        };
        /**
         * Returns the start index and end index of the currently selected text range. Returns `undefined`
         * if no text is currently selected.
         */
        NgxAnnotateTextComponent.prototype.getCurrentTextSelection = function () {
            this.updateTextSelection();
            if (this.selectionStart === undefined || this.selectionEnd === undefined || this.selectionStart >= this.selectionEnd) {
                return undefined;
            }
            return {
                startIndex: this.selectionStart,
                endIndex: this.selectionEnd,
            };
        };
        /** @internal */
        NgxAnnotateTextComponent.prototype.isAnnotation = function (annotation) {
            return annotation instanceof Annotation;
        };
        /** @internal */
        NgxAnnotateTextComponent.prototype.onRemoveAnnotation = function (annotation) {
            this.annotations = this.annotations.filter(function (a) { return a !== annotation; });
            this.annotationsChange.emit(this.annotations);
            this.splitTextIntoTokens();
        };
        NgxAnnotateTextComponent.prototype.updateTextSelection = function () {
            if (window.getSelection && window.getSelection().rangeCount > 0) {
                var range = window.getSelection().getRangeAt(0);
                var preSelectionRange = range.cloneRange();
                preSelectionRange.selectNodeContents(this.elementRef.nativeElement);
                preSelectionRange.setEnd(range.startContainer, range.startOffset);
                this.selectionStart = __spread(preSelectionRange.toString()).length;
                this.selectionEnd = this.selectionStart + __spread(range.toString()).length;
            }
            else {
                this.selectionStart = undefined;
                this.selectionEnd = undefined;
            }
        };
        NgxAnnotateTextComponent.prototype.splitTextIntoTokens = function () {
            var _this = this;
            this.tokens = [];
            this.annotationStartingIndices = new Map();
            // Creates a map which contains the starting indices for each annotation
            // as keys. This way, we know the positions / indices in the text where
            // we need to display an annotation instead of the plaintext.
            this.annotations.forEach(function (a) {
                _this.annotationStartingIndices.set(a.startIndex, a);
                a.text = _this.text.substring(a.startIndex, a.endIndex);
            });
            var currentIndex = 0;
            var isAnnotationActive = false;
            var annotationActiveUntilIndex = 0;
            var buffer = '';
            this.text.split('').forEach(function (char) {
                if (annotationActiveUntilIndex === currentIndex) {
                    isAnnotationActive = false;
                }
                if (!_this.annotationStartingIndices.has(currentIndex) && !isAnnotationActive) {
                    buffer += char;
                }
                else if (_this.annotationStartingIndices.has(currentIndex)) {
                    if (buffer.length > 0) {
                        _this.tokens.push(buffer);
                    }
                    _this.tokens.push(_this.annotationStartingIndices.get(currentIndex));
                    annotationActiveUntilIndex = _this.annotationStartingIndices.get(currentIndex).endIndex;
                    buffer = '';
                    isAnnotationActive = true;
                }
                currentIndex++;
            });
            if (buffer.length > 0) {
                this.tokens.push(buffer);
            }
        };
        return NgxAnnotateTextComponent;
    }());
    NgxAnnotateTextComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-annotate-text',
                    template: "<span *ngFor=\"let token of tokens\">\n\n  <ngx-annotation *ngIf=\"isAnnotation(token)\" [annotation]=\"token\" [removable]=\"removable\"\n    (removeAnnotation)=\"onRemoveAnnotation($event)\" [class]=\"(annotationClass || '')\">\n  </ngx-annotation>\n\n  <span *ngIf=\"!isAnnotation(token)\" class=\"unlabeled\">{{ token }}</span>\n\n</span>",
                    styles: [":host(){align-items:flex-start;display:flex;flex-wrap:wrap;white-space:pre-wrap}span.unlabeled{line-height:1.5rem}"]
                },] }
    ];
    NgxAnnotateTextComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    NgxAnnotateTextComponent.propDecorators = {
        annotations: [{ type: core.Input }],
        annotationClass: [{ type: core.Input }],
        removable: [{ type: core.Input }],
        text: [{ type: core.Input }],
        annotationsChange: [{ type: core.Output }]
    };

    var NgxAnnotateTextModule = /** @class */ (function () {
        function NgxAnnotateTextModule() {
        }
        return NgxAnnotateTextModule;
    }());
    NgxAnnotateTextModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        AnnotationComponent,
                        NgxAnnotateTextComponent,
                    ],
                    imports: [
                        platformBrowser.BrowserModule,
                    ],
                    exports: [NgxAnnotateTextComponent]
                },] }
    ];

    /*
     * Public API Surface of ngx-annotate-text
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.Annotation = Annotation;
    exports.NgxAnnotateTextComponent = NgxAnnotateTextComponent;
    exports.NgxAnnotateTextModule = NgxAnnotateTextModule;
    exports.ɵa = AnnotationComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-annotate-text.umd.js.map
