!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@angular/core"),require("@angular/platform-browser")):"function"==typeof define&&define.amd?define("ngx-annotate-text",["exports","@angular/core","@angular/platform-browser"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self)["ngx-annotate-text"]={},t.ng.core,t.ng.platformBrowser)}(this,(function(t,n,e){"use strict";var o=function(){this.removable=!0,this.removeAnnotation=new n.EventEmitter};o.decorators=[{type:n.Component,args:[{selector:"ngx-annotation",template:'<span class="annotation-parent" [style.border-color]="annotation.color" [style.background-color]="annotation.color">\n\n    <span class="annotation-content">\n        <pre>{{ annotation.text }}</pre>\n    </span>\n\n    \x3c!-- Instead of setting the property "innerText" of this HTML element, we set "data-label".\n        In CSS, we can then reference the content of this property and can use the CSS pseudo-\n        element "::after" to insert the content of "data-label" as text into the DOM.\n        What\'s the advantage of this? At first, I tried to use the "innerText" property of this\n        HTML element to visualize the annotation\'s label. Whenever the user selected a range of\n        the original text, then the labels of the annotations were counted into the range, too.\n        This made it difficult to extract which text range the user actually selected. By using\n        the CSS pseudo-class "::after", we can prevent the annotations\' labels from being\n        included into the selected text range. --\x3e\n    <span class="annotation-label" [attr.data-label]="annotation.label" [style.background-color]="annotation.color">\n    </span>\n\n    <span class="annotation-button" *ngIf="removable">\n        <span>\n            <button class="remove-annotation" (click)="removeAnnotation.emit(annotation)">\n            </button>\n        </span>\n    </span>\n\n</span>',styles:['span.annotation-parent{border:2px solid;border-radius:4px;box-shadow:2px 4px 20px rgba(0,0,0,.1);color:rgba(0,0,0,.6);display:block;font-weight:500;line-height:1.5;margin:0 0 .5rem;min-width:26px;padding:0;white-space:normal;word-break:break-word;word-wrap:break-word}span.annotation-content{align-items:center;background-color:#fff;border-top-left-radius:2px;border-top-right-radius:2px;display:flex;flex-wrap:wrap;justify-content:center;padding:0 2px;text-align:center;white-space:normal}span.annotation-content pre{background-color:transparent;box-sizing:border-box;color:inherit;display:block;font-family:inherit;font-size:inherit;margin-bottom:0;margin-top:0;overflow:auto;padding:0}span.annotation-label{-webkit-touch-callout:none;-webkit-user-select:none;align-items:center;color:#fff;display:flex;justify-content:center;line-height:.8rem;margin:0;padding:2px 8px 0;text-align:center;user-select:none}span.annotation-label:after{content:attr(data-label)}span.annotation-button{display:block;height:0;position:relative;width:100%}span.annotation-button span{position:absolute;right:.47rem;top:-2.9rem}button.remove-annotation{-moz-appearance:none;-webkit-appearance:none;-webkit-user-select:none;appearance:none;background-color:rgba(10,10,10,.2);border:none;border-radius:1000px;cursor:pointer;display:inline-block;flex-grow:0;flex-shrink:0;height:16px;max-height:16px;max-width:16px;min-height:16px;min-width:16px;outline:0;position:absolute;user-select:none;width:16px}button.remove-annotation:hover{background-color:rgba(10,10,10,.5)}button.remove-annotation:after,button.remove-annotation:before{background-color:#fff;content:"";display:block;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%) rotate(45deg);transform-origin:center center}button.remove-annotation:after{height:50%;width:2px}button.remove-annotation:before{height:2px;width:50%}']}]}],o.ctorParameters=function(){return[]},o.propDecorators={annotation:[{type:n.Input}],removable:[{type:n.Input}],removeAnnotation:[{type:n.Output}]};Object.create;function a(t,n){var e="function"==typeof Symbol&&t[Symbol.iterator];if(!e)return t;var o,a,i=e.call(t),r=[];try{for(;(void 0===n||n-- >0)&&!(o=i.next()).done;)r.push(o.value)}catch(t){a={error:t}}finally{try{o&&!o.done&&(e=i.return)&&e.call(i)}finally{if(a)throw a.error}}return r}function i(){for(var t=[],n=0;n<arguments.length;n++)t=t.concat(a(arguments[n]));return t}Object.create;var r=function(t,n,e,o){this.startIndex=t,this.endIndex=n,this.label=e,this.color=o},s=function(){function t(t){this.elementRef=t,this.annotations=[],this.removable=!0,this.annotationsChange=new n.EventEmitter,this.tokens=[],this.annotationStartingIndices=new Map}return t.prototype.ngOnInit=function(){this.splitTextIntoTokens()},t.prototype.ngOnChanges=function(t){("annotations"in t||"text"in t)&&this.splitTextIntoTokens()},t.prototype.getCurrentTextSelection=function(){if(this.updateTextSelection(),!(void 0===this.selectionStart||void 0===this.selectionEnd||this.selectionStart>=this.selectionEnd))return{startIndex:this.selectionStart,endIndex:this.selectionEnd}},t.prototype.isAnnotation=function(t){return t instanceof r},t.prototype.onRemoveAnnotation=function(t){this.annotations=this.annotations.filter((function(n){return n!==t})),this.annotationsChange.emit(this.annotations),this.splitTextIntoTokens()},t.prototype.updateTextSelection=function(){if(window.getSelection&&window.getSelection().rangeCount>0){var t=window.getSelection().getRangeAt(0),n=t.cloneRange();n.selectNodeContents(this.elementRef.nativeElement),n.setEnd(t.startContainer,t.startOffset),this.selectionStart=i(n.toString()).length,this.selectionEnd=this.selectionStart+i(t.toString()).length}else this.selectionStart=void 0,this.selectionEnd=void 0},t.prototype.splitTextIntoTokens=function(){var t=this;this.tokens=[],this.annotationStartingIndices=new Map,this.annotations.forEach((function(n){t.annotationStartingIndices.set(n.startIndex,n),n.text=t.text.substring(n.startIndex,n.endIndex)}));var n=0,e=!1,o=0,a="";this.text.split("").forEach((function(i){o===n&&(e=!1),t.annotationStartingIndices.has(n)||e?t.annotationStartingIndices.has(n)&&(a.length>0&&t.tokens.push(a),t.tokens.push(t.annotationStartingIndices.get(n)),o=t.annotationStartingIndices.get(n).endIndex,a="",e=!0):a+=i,n++})),a.length>0&&this.tokens.push(a)},t}();s.decorators=[{type:n.Component,args:[{selector:"ngx-annotate-text",template:'<span *ngFor="let token of tokens">\n\n  <ngx-annotation *ngIf="isAnnotation(token)" [annotation]="token" [removable]="removable"\n    (removeAnnotation)="onRemoveAnnotation($event)" [class]="(annotationClass || \'\')">\n  </ngx-annotation>\n\n  <span *ngIf="!isAnnotation(token)" class="unlabeled">{{ token }}</span>\n\n</span>',styles:[":host(){align-items:flex-start;display:flex;flex-wrap:wrap;white-space:pre-wrap}span.unlabeled{line-height:1.5rem}"]}]}],s.ctorParameters=function(){return[{type:n.ElementRef}]},s.propDecorators={annotations:[{type:n.Input}],annotationClass:[{type:n.Input}],removable:[{type:n.Input}],text:[{type:n.Input}],annotationsChange:[{type:n.Output}]};var l=function(){};l.decorators=[{type:n.NgModule,args:[{declarations:[o,s],imports:[e.BrowserModule],exports:[s]}]}],t.Annotation=r,t.NgxAnnotateTextComponent=s,t.NgxAnnotateTextModule=l,t.Éµa=o,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=ngx-annotate-text.umd.min.js.map