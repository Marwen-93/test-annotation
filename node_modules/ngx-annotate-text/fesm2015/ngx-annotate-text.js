import { EventEmitter, Component, Input, Output, ElementRef, NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

class AnnotationComponent {
    constructor() {
        this.removable = true;
        this.removeAnnotation = new EventEmitter();
    }
}
AnnotationComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-annotation',
                template: "<span class=\"annotation-parent\" [style.border-color]=\"annotation.color\" [style.background-color]=\"annotation.color\">\n\n    <span class=\"annotation-content\">\n        <pre>{{ annotation.text }}</pre>\n    </span>\n\n    <!-- Instead of setting the property \"innerText\" of this HTML element, we set \"data-label\".\n        In CSS, we can then reference the content of this property and can use the CSS pseudo-\n        element \"::after\" to insert the content of \"data-label\" as text into the DOM.\n        What's the advantage of this? At first, I tried to use the \"innerText\" property of this\n        HTML element to visualize the annotation's label. Whenever the user selected a range of\n        the original text, then the labels of the annotations were counted into the range, too.\n        This made it difficult to extract which text range the user actually selected. By using\n        the CSS pseudo-class \"::after\", we can prevent the annotations' labels from being\n        included into the selected text range. -->\n    <span class=\"annotation-label\" [attr.data-label]=\"annotation.label\" [style.background-color]=\"annotation.color\">\n    </span>\n\n    <span class=\"annotation-button\" *ngIf=\"removable\">\n        <span>\n            <button class=\"remove-annotation\" (click)=\"removeAnnotation.emit(annotation)\">\n            </button>\n        </span>\n    </span>\n\n</span>",
                styles: ["span.annotation-parent{border:2px solid;border-radius:4px;box-shadow:2px 4px 20px rgba(0,0,0,.1);color:rgba(0,0,0,.6);display:block;font-weight:500;line-height:1.5;margin:0 0 .5rem;min-width:26px;padding:0;white-space:normal;word-break:break-word;word-wrap:break-word}span.annotation-content{align-items:center;background-color:#fff;border-top-left-radius:2px;border-top-right-radius:2px;display:flex;flex-wrap:wrap;justify-content:center;padding:0 2px;text-align:center;white-space:normal}span.annotation-content pre{background-color:transparent;box-sizing:border-box;color:inherit;display:block;font-family:inherit;font-size:inherit;margin-bottom:0;margin-top:0;overflow:auto;padding:0}span.annotation-label{-webkit-touch-callout:none;-webkit-user-select:none;align-items:center;color:#fff;display:flex;justify-content:center;line-height:.8rem;margin:0;padding:2px 8px 0;text-align:center;user-select:none}span.annotation-label:after{content:attr(data-label)}span.annotation-button{display:block;height:0;position:relative;width:100%}span.annotation-button span{position:absolute;right:.47rem;top:-2.9rem}button.remove-annotation{-moz-appearance:none;-webkit-appearance:none;-webkit-user-select:none;appearance:none;background-color:rgba(10,10,10,.2);border:none;border-radius:1000px;cursor:pointer;display:inline-block;flex-grow:0;flex-shrink:0;height:16px;max-height:16px;max-width:16px;min-height:16px;min-width:16px;outline:0;position:absolute;user-select:none;width:16px}button.remove-annotation:hover{background-color:rgba(10,10,10,.5)}button.remove-annotation:after,button.remove-annotation:before{background-color:#fff;content:\"\";display:block;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%) rotate(45deg);transform-origin:center center}button.remove-annotation:after{height:50%;width:2px}button.remove-annotation:before{height:2px;width:50%}"]
            },] }
];
AnnotationComponent.ctorParameters = () => [];
AnnotationComponent.propDecorators = {
    annotation: [{ type: Input }],
    removable: [{ type: Input }],
    removeAnnotation: [{ type: Output }]
};

class Annotation {
    /**
     * Represents an annotated part of the referenced text.
     *
     * @param startIndex The zero-based index number indicating the beginning of this annotation.
     * @param endIndex The zero-based index number indicating the end of the annotation. The annotation
     * includes the characters up to, but not including, the character indicated by the end.
     * @param label Arbitrary string displayed as label below the annotation, e. g. `City`.
     * @param color The color of the box which is displayed around the annotation, e. g. 'red' or 'rgb(220, 53, 69)'.
     */
    constructor(startIndex, endIndex, label, color) {
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.label = label;
        this.color = color;
    }
}

class NgxAnnotateTextComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /** Represents the parts of the given text which shall be annotated. */
        this.annotations = [];
        /**
         * Determines whether annotations shall have a small button in the top right corner so that the user can
         * remove an annotation.
         */
        this.removable = true;
        /** Emits the list of existing annotations after an element has been removed. */
        this.annotationsChange = new EventEmitter();
        /** @internal */
        this.tokens = [];
        this.annotationStartingIndices = new Map();
    }
    ngOnInit() {
        this.splitTextIntoTokens();
    }
    ngOnChanges(changes) {
        if ('annotations' in changes || 'text' in changes) {
            this.splitTextIntoTokens();
        }
    }
    /**
     * Returns the start index and end index of the currently selected text range. Returns `undefined`
     * if no text is currently selected.
     */
    getCurrentTextSelection() {
        this.updateTextSelection();
        if (this.selectionStart === undefined || this.selectionEnd === undefined || this.selectionStart >= this.selectionEnd) {
            return undefined;
        }
        return {
            startIndex: this.selectionStart,
            endIndex: this.selectionEnd,
        };
    }
    /** @internal */
    isAnnotation(annotation) {
        return annotation instanceof Annotation;
    }
    /** @internal */
    onRemoveAnnotation(annotation) {
        this.annotations = this.annotations.filter(a => a !== annotation);
        this.annotationsChange.emit(this.annotations);
        this.splitTextIntoTokens();
    }
    updateTextSelection() {
        if (window.getSelection && window.getSelection().rangeCount > 0) {
            const range = window.getSelection().getRangeAt(0);
            const preSelectionRange = range.cloneRange();
            preSelectionRange.selectNodeContents(this.elementRef.nativeElement);
            preSelectionRange.setEnd(range.startContainer, range.startOffset);
            this.selectionStart = [...preSelectionRange.toString()].length;
            this.selectionEnd = this.selectionStart + [...range.toString()].length;
        }
        else {
            this.selectionStart = undefined;
            this.selectionEnd = undefined;
        }
    }
    splitTextIntoTokens() {
        this.tokens = [];
        this.annotationStartingIndices = new Map();
        // Creates a map which contains the starting indices for each annotation
        // as keys. This way, we know the positions / indices in the text where
        // we need to display an annotation instead of the plaintext.
        this.annotations.forEach((a) => {
            this.annotationStartingIndices.set(a.startIndex, a);
            a.text = this.text.substring(a.startIndex, a.endIndex);
        });
        let currentIndex = 0;
        let isAnnotationActive = false;
        let annotationActiveUntilIndex = 0;
        let buffer = '';
        this.text.split('').forEach((char) => {
            if (annotationActiveUntilIndex === currentIndex) {
                isAnnotationActive = false;
            }
            if (!this.annotationStartingIndices.has(currentIndex) && !isAnnotationActive) {
                buffer += char;
            }
            else if (this.annotationStartingIndices.has(currentIndex)) {
                if (buffer.length > 0) {
                    this.tokens.push(buffer);
                }
                this.tokens.push(this.annotationStartingIndices.get(currentIndex));
                annotationActiveUntilIndex = this.annotationStartingIndices.get(currentIndex).endIndex;
                buffer = '';
                isAnnotationActive = true;
            }
            currentIndex++;
        });
        if (buffer.length > 0) {
            this.tokens.push(buffer);
        }
    }
}
NgxAnnotateTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-annotate-text',
                template: "<span *ngFor=\"let token of tokens\">\n\n  <ngx-annotation *ngIf=\"isAnnotation(token)\" [annotation]=\"token\" [removable]=\"removable\"\n    (removeAnnotation)=\"onRemoveAnnotation($event)\" [class]=\"(annotationClass || '')\">\n  </ngx-annotation>\n\n  <span *ngIf=\"!isAnnotation(token)\" class=\"unlabeled\">{{ token }}</span>\n\n</span>",
                styles: [":host(){align-items:flex-start;display:flex;flex-wrap:wrap;white-space:pre-wrap}span.unlabeled{line-height:1.5rem}"]
            },] }
];
NgxAnnotateTextComponent.ctorParameters = () => [
    { type: ElementRef }
];
NgxAnnotateTextComponent.propDecorators = {
    annotations: [{ type: Input }],
    annotationClass: [{ type: Input }],
    removable: [{ type: Input }],
    text: [{ type: Input }],
    annotationsChange: [{ type: Output }]
};

class NgxAnnotateTextModule {
}
NgxAnnotateTextModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    AnnotationComponent,
                    NgxAnnotateTextComponent,
                ],
                imports: [
                    BrowserModule,
                ],
                exports: [NgxAnnotateTextComponent]
            },] }
];

/*
 * Public API Surface of ngx-annotate-text
 */

/**
 * Generated bundle index. Do not edit.
 */

export { Annotation, NgxAnnotateTextComponent, NgxAnnotateTextModule, AnnotationComponent as ɵa };
//# sourceMappingURL=ngx-annotate-text.js.map
